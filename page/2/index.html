<!DOCTYPE html>



  


<html class="theme-next mist use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.3" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png?v=5.1.3">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32.png?v=5.1.3">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16.png?v=5.1.3">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.3" color="#222">





  <meta name="keywords" content="Hexo, NexT">










<meta property="og:type" content="website">
<meta property="og:title" content="Lemon&#39;s Blog">
<meta property="og:url" content="https://blog.lemongame.top/page/2/index.html">
<meta property="og:site_name" content="Lemon&#39;s Blog">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Lemon&#39;s Blog">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    version: '5.1.3',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://blog.lemongame.top/page/2/">





  <title>Lemon's Blog</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta custom-logo">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Lemon's Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-首页">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-标签">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-分类">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-归档">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-关于">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br>
            
            关于
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://blog.lemongame.top/undefined/clang/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="疯狂小柠檬">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Lemon's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/undefined/clang/" itemprop="url">clang</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-08-27T18:47:49+08:00">
                2019-08-27
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="clang-命令"><a href="#clang-命令" class="headerlink" title="clang 命令"></a>clang 命令</h3><p>1、重新编译.m文件</p>
<pre><code>clang -rewrite-objc 文件</code></pre><p>或</p>
<pre><code>clang -rewrite-objc -fobjc-arc -stdlib=libc++ -mmacosx-version-min=10.7 -fobjc-runtime=macosx-10.7 -Wno-deprecated-declarations main.m</code></pre>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://blog.lemongame.top/undefined/charles原理/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="疯狂小柠檬">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Lemon's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/undefined/charles原理/" itemprop="url">charles原理</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-08-27T18:45:49+08:00">
                2019-08-27
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="Charles抓包原理"><a href="#Charles抓包原理" class="headerlink" title="Charles抓包原理"></a>Charles抓包原理</h3><p>HTTPS为了兼顾安全与效率，同时使用了对称加密和非对称加密。数据是被对称加密传输的，对称加密过程需要客户端的一个密钥，为了确保能把该密钥安全传输到服务器端，采用非对称加密对该密钥进行加密传输，总的来说，对数据进行对称加密，对称加密所要使用的密钥通过非对称加密传输。</p>
<p>Charles抓包采用的是中间人代理的模式</p>
<p><img src="https://raw.githubusercontent.com/xuehan111/images/master/charles.png" alt="charles.png"></p>
<p>1、客户端向服务器请求CA证书</p>
<p>2、Charles拦截客户端的请求，伪装成客户端向服务器请求</p>
<p>3、服务器向客户端(Charles)返回服务器自己的CA证书</p>
<p>4、Charles拦截服务器的响应，获取服务器证书公钥，然后自己制作一张证书，将服务器证书替换后发送给客户端。（这一步，Charles拿到了服务器证书的公钥）</p>
<p>5、客户端接收到“服务器”（实际上是Charles）的证书后，生成一个对称密钥，用Charles的公钥加密，发送给“服务器”（Charles）</p>
<p>6、Charles拦截客户端的响应，用自己的私钥解密对称密钥，然后用服务器证书公钥加密，发送给服务器。（这一步，Charles拿到了对称密钥</p>
<p>7、服务器用自己的私钥解密对称密钥，向“客户端”（Charles）发送响应</p>
<p>8、Charles拦截服务器的响应，替换成自己的证书后发送给客户端</p>
<p>9、至此，连接建立，Charles拿到了 服务器证书的公钥 和 客户端与服务器协商的对称密钥，之后就可以解密或者修改加密的报文了。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://blog.lemongame.top/undefined/block/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="疯狂小柠檬">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Lemon's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/undefined/block/" itemprop="url">block</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-08-27T18:42:23+08:00">
                2019-08-27
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="深入理解block"><a href="#深入理解block" class="headerlink" title="深入理解block"></a>深入理解block</h3><h4 id="Block的使用"><a href="#Block的使用" class="headerlink" title="Block的使用"></a>Block的使用</h4><pre><code>// 定义Block类型
typedef void(^Block)(NSString *name);
// 作为属性
@property (nonatomic, copy) void (^Block)(NSString *name);
// 作为参数
- (void)addAction:(void(^)(NSString *name))result;

Block block = ^(NSString *name){

};
self.Block = ^(NSString *name) {

};
void (^block)(NSString *temp) = ^(NSString *temp){

};</code></pre><h4 id="Block的内存管理"><a href="#Block的内存管理" class="headerlink" title="Block的内存管理"></a>Block的内存管理</h4><p>iOS 将Block分为三类，<strong>NSGlobalBlock</strong>，<strong>NSStackBlock</strong>，<strong>NSMallocBlock</strong>。其在内存中的存储如下。</p>
<table>
<thead>
<tr>
<th>Block</th>
<th>存储</th>
</tr>
</thead>
<tbody><tr>
<td><strong>NSGlobalBlock</strong></td>
<td>全局区</td>
</tr>
<tr>
<td><strong>NSStackBlock</strong></td>
<td>栈区</td>
</tr>
<tr>
<td><strong>NSMallocBlock</strong></td>
<td>堆区</td>
</tr>
</tbody></table>
<p><strong>NSGlobalBlock</strong>: 么有引用外部变量，或者引用了静态变量或全局变量</p>
<p><strong>NSStackBlock</strong>: 在MRC下，引用了外部局部变量的block</p>
<p><strong>NSMallocBlock</strong>: 在ARC下，引用了外部局部变量的block</p>
<p> <code>Note:在ARC下，引用了外部局部变量的block,会进行copy操作，所以在ARC下不存在__NSStackBlock__</code>。</p>
<h5 id="Block自己的内存管理"><a href="#Block自己的内存管理" class="headerlink" title="Block自己的内存管理"></a>Block自己的内存管理</h5><p>对于block，有两个内存管理方法：Block_copy, Block_release;Block_copy与copy等效， Block_release与release等效；</p>
<ul>
<li>不管是对block进行retian,copy,release,block的引用计数都不会增加，始终为1；</li>
<li>NSGlobalBlock:使用retain,copy, release都无效，block依旧存在全局区，且没有释放, 使用copy和retian只是返回block的指针；</li>
<li>NSStackBlock:使用retain,release操作无效；栈区block会在方法返回后将block空间回收； 使用copy将栈区block复制到堆区，可以长久保留block的空间，以供后面的程序使用；</li>
<li>NSMallocBlock:支持retian,release，虽然block的引用计数始终为1，但内存中还是会对引用进行管理，使用Block_copy引用+1， Block_release引用-1； 对于NSMallocBlock使用copy之后,不会产生新的block，只是增加了一次引用，类似于使用retian;</li>
</ul>
<h5 id="Block引用变量的内存管理"><a href="#Block引用变量的内存管理" class="headerlink" title="Block引用变量的内存管理"></a>Block引用变量的内存管理</h5><p>Block 引用局部变量，是值传递，引用全局变量和静态变量，是指针传递。<br>Block的结构如下：</p>
<p><img src="https://raw.githubusercontent.com/xuehan111/images/master/block_layout.png" alt="Block_Layout"></p>
<p>对于<strong>block修饰的变量，如:</strong>block int a = 10;会在栈区用block结构体方式保存。</p>
<pre><code>struct __Block_byref_b_0 {
      void *__isa;
    __Block_byref_b_0 *__forwarding;
     int __flags;
     int __size;
     int a;
};</code></pre><p>此时，__forwarding 指针指向block自身。</p>
<p><img src="https://raw.githubusercontent.com/xuehan111/images/master/stackBlock.png" alt="stackBlock.png"></p>
<p>使用Block_copy复制到对上之后，栈区的block中的__forwarding指向堆区的地址。</p>
<p><img src="https://raw.githubusercontent.com/xuehan111/images/master/heapBlock.png" alt="heapBlock.png"></p>
<h4 id="Blcok-copy"><a href="#Blcok-copy" class="headerlink" title="Blcok_copy"></a>Blcok_copy</h4><pre><code>void *_Block_copy(const void *arg) { 
    return _Block_copy_internal(arg, WANTS_ONE); 
} </code></pre><p>上面的方法调用了_Block_copy_internal()函数，查看_Block_copy_internal方法的实现：</p>
<pre><code>static void *_Block_copy_internal(const void *arg, const int flags) { 
    struct Block_layout *aBlock; 
    const bool wantsOne = (WANTS_ONE &amp;amp; flags) == WANTS_ONE; 

    // 1 
    if (!arg) return NULL; 

    // 2 
    aBlock = (struct Block_layout *)arg; 

    // 3 
    if (aBlock-&gt;flags &amp;amp; BLOCK_NEEDS_FREE) { 
        // latches on high 
        latching_incr_int(&amp;amp;aBlock-&gt;flags); 
        return aBlock; 
    } 

    // 4 
    else if (aBlock-&gt;flags &amp;amp; BLOCK_IS_GLOBAL) { 
        return aBlock; 
    } 

    // 5 
    struct Block_layout *result = malloc(aBlock&gt;descriptor-&gt;size); 
    if (!result) return (void *)0; 

    // 6 
    memmove(result, aBlock, aBlock-&gt;descriptor-&gt;size); // bitcopy first 

    // 7 
    result-&gt;flags &amp;amp;= ~(BLOCK_REFCOUNT_MASK);    // XXX not needed 
    result-&gt;flags |= BLOCK_NEEDS_FREE | 1; 

    // 8 
    result-&gt;isa = _NSConcreteMallocBlock; 

    // 9 
    if (result-&gt;flags &amp;amp; BLOCK_HAS_COPY_DISPOSE) { 
        (*aBlock-&gt;descriptor-&gt;copy)(result, aBlock); // do fixup 
    } 

    return result; 
} </code></pre><p>下面来看看该方法都做了些什么事情：</p>
<p>1、如果传入的参数是NULL则直接返回NULL。这样可以保证传入一个NULL block时函数的安全性。</p>
<p>2、将参数强制转换为一个指针，该指针指向一个Block_layout结构对象。实际上在第一集中就介绍了Block_layout结构：这是一个内部使用的数据结构，该结构组成一个block，其中包含一个block的实现函数，以及另外几个元数据。</p>
<p>3、 如果block的flags包含BLOCK_NEEDS_FREE，说明这是一个堆block(a heap block)。这种情况下，需要做的事情就是增加引用计数(reference count)，然后将同一个的block返回。</p>
<p>4、如果block是一个全局block(参考第一集)，那么不用做任何事情，直接返回同一个block即可——因为全局block是一个单例(singleton)。</p>
<p>5、如果到这一步了，可以肯定该block肯定被分配在栈上。这种情况，需要将block拷贝到堆上。这也是最有趣的一部分。首先是利用malloc()函数在堆上创建block对应size大小的内存空间。如果失败了，就返回NULL，否则继续往下执行。</p>
<p>6、 利用memmove()函数将分配在栈中的block按位拷贝至刚刚在堆上分配的空间中。按位拷贝可以确保block中的所有元数据都能准确的进行拷贝，例如block的descriptor。</p>
<p>7、接着需要更新一下block的flags。第一行代码是确保引用计数被设置为0。后面紧跟的注释表示这不是必须的——估计此时引用计数已经是0了。我猜测这行代码的作用是为了防止潜在的bug，会引起引用计数不为0的情况。第二行代码是设置BLOCK_NEEDS_FREE标志，这标示该block是一个堆block，当引用计数变为0时，需要free掉。后面紧跟的| 1是将block的引用计数设置为1。</p>
<p>8、将block的isa指针设置为 _NSConcreteMallocBlock，这就意味着该block是一个堆block。</p>
<p>9、最后，如果block有一个拷贝辅助函数(a copy helper function)，那么就调用它。如果有必要的话，表一起会生成一个拷贝辅助函数。例如block需要拷贝对象的时候，拷贝辅助函数会retain住已经拷贝的对象。</p>
<p>####Block_release<br>与Block_copy对应的是Block_release()。同样，Block_release()也是一个宏定义，如下所示：</p>
<pre><code>#define Block_release(...) _Block_release((const void *)(__VA_ARGS__)) 

void _Block_release(void *arg) { 
    // 1 
    struct Block_layout *aBlock = (struct Block_layout *)arg; 
    if (!aBlock) return; 

    // 2 
    int32_t newCount; 
    newCount = latching_decr_int(&amp;amp;aBlock-&gt;flags) &amp;amp; BLOCK_REFCOUNT_MASK; 

    // 3 
    if (newCount &gt; 0) return; 

    // 4 
    if (aBlock-&gt;flags &amp;amp; BLOCK_NEEDS_FREE) { 
        if (aBlock-&gt;flags &amp;amp; BLOCK_HAS_COPY_DISPOSE)(*aBlock-&gt;descriptor-&gt;dispose)(aBlock); 
        _Block_deallocator(aBlock); 
    } 

    // 5 
    else if (aBlock-&gt;flags &amp;amp; BLOCK_IS_GLOBAL) { 
        ; 
    } 

    // 6 
    else { 
        printf(&quot;Block_release called upon a stack Block: %p, ignored\n&quot;, (void *)aBlock); 
    } 
} </code></pre><p>1、 首先将参数强制转换为Block_layout结构。如果传入的是NULL，那么为了函数的安全起见，将直接返回。</p>
<p>2、将block的引用计数标志位减1(还记得Block_copy()中将这个引用计数标志位设置为1吗？)。</p>
<p>3、如果newCount大于0，说明还有别的对象引用了这个block，所以并不需要立即释放block，只需简单的返回即可。</p>
<p>4、否则，如果flags中包含BLOCK_NEEDS_FREE，那么说明这个block是分配到堆上的，并且如果引用计数为0，那么需要释放这个block。首先是调用了block的dispose辅助函数，该函数跟copy辅助函数相反，负责做相反的操作，例如释放掉所有在block中拷贝的变量等。最后使用_Block_deallocator函数释放掉block，如果你去runtime.c文件中看看，会发现该函数的尾部是一个指向free的函数指针，也就是释放掉malloc分配的内存。</p>
<p>5、如果block是全局的，那么什么事情也不用做。</p>
<p>6、如果代码执行到这里了，会发生一些奇怪的事情：因为正在尝试将栈上的block释放掉，所以这行代码是为了提醒开发者的。在程序实际运行过程中，永远不会看到这里的提示。</p>
<h4 id="Block-循环引用的解决"><a href="#Block-循环引用的解决" class="headerlink" title="Block 循环引用的解决"></a>Block 循环引用的解决</h4>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://blog.lemongame.top/undefined/App启动/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="疯狂小柠檬">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Lemon's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/undefined/App启动/" itemprop="url">App启动</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-08-27T18:39:35+08:00">
                2019-08-27
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="App启动加载"><a href="#App启动加载" class="headerlink" title="App启动加载"></a>App启动加载</h3><p>当我们点击App图标时，便进入了App的启动过程，整个过程大致进行了如下操作:<br><img src="https://raw.githubusercontent.com/xuehan111/images/master/ios_app_start.png" alt="app start"></p>
<h3 id="启动优化"><a href="#启动优化" class="headerlink" title="启动优化"></a>启动优化</h3><p><a href="http://www.cocoachina.com/ios/20180802/24423.html" target="_blank" rel="noopener">链接</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://blog.lemongame.top/undefined/App的编译过程/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="疯狂小柠檬">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Lemon's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/undefined/App的编译过程/" itemprop="url">App的编译过程</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-08-27T18:35:26+08:00">
                2019-08-27
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="App的编译"><a href="#App的编译" class="headerlink" title="App的编译"></a>App的编译</h3><h4 id="Command-R发生了什么"><a href="#Command-R发生了什么" class="headerlink" title="Command+R发生了什么"></a>Command+R发生了什么</h4><ul>
<li>写入辅助文件：将项目的文件结构对应表、将要执行的脚本、项目依赖库的文件结构对应表写成文件，方便后面使用；并且创建一个 .app 包，后面编译后的文件都会被放入包中；</li>
<li>运行预设脚本：Cocoapods 会预设一些脚本，当然你也可以自己预设一些脚本来运行。这些脚本都在 Build Phases 中可以看到；</li>
<li>编译文件：针对每一个文件进行编译，生成可执行文件 Mach-O，这过程 LLVM 的完整流程，前端、优化器、后端；</li>
<li>链接文件：将项目中的多个可执行文件合并成一个文件；</li>
<li>拷贝资源文件：将项目中的资源文件拷贝到目标包；</li>
<li>编译 storyboard 文件：storyboard 文件也是会被编译的；</li>
<li>链接 storyboard 文件：将编译后的 storyboard 文件链接成一个文件；</li>
<li>编译 Asset 文件：我们的图片如果使用 Assets.xcassets 来管理图片，那么这* 些图片将会被编译成机器码，除了 icon 和 launchImage；</li>
<li>运行 Cocoapods 脚本：将在编译项目之前已经编译好的依赖库和相关资源拷贝到包中。</li>
<li>生成 .app 包</li>
<li>对包进行签名、验证</li>
</ul>
<h3 id="编译优化"><a href="#编译优化" class="headerlink" title="编译优化"></a>编译优化</h3><ul>
<li><p>Build Active Architecture Only</p>
<pre><code>Note: 
在Debug模式下，设置为YES，只会生成指定指令集的二进制包,
在release模式下设置为NO</code></pre></li>
<li><p>Optimization Level</p>
<pre><code>该变量有以下值可以设置
* None: 编译器不会尝试优化代码，当你专注解决逻辑错误、编译速度快时使用此项。</code></pre><ul>
<li><p>Fast: 编译器执行简单的优化来提高代码的性能，同时最大限度的减少编译时间，该选项在编译过程中会使用更多的内存。</p>
</li>
<li><p>Faster: 编译器执行所有优化，增加编译时间，提高代码的性能。</p>
</li>
<li><p>Fastest: 编译器执行所有优化，改善代码的速度，但会增加代码长度，编译速度慢。</p>
</li>
<li><p>Fastest, Smallest: 编译器执行所有优化，不会增加代码的长度，它是执行文件占用更少内存的首选方案</p>
<pre><code>在Debug环境下设置为None，从而减少编译时间
在Release环境下设置为Fastest, Smalllest，这样既能执行所有的优化而不增加代码长度，又能使执行文件占用更少的内存</code></pre></li>
</ul>
</li>
<li><p>Debug Information Format</p>
<p>  该值表示是否将调试信息加入到可执行文件中，即是否生成dSYM文件</p>
<ul>
<li><p>DWARF  不生成dSYM调试文件</p>
</li>
<li><p>DWARF with dSYM file  生成调试文件</p>
<pre><code>在Debug环境下设置为DWARF，在release环境下设置为DWARF with dSYM file</code></pre></li>
</ul>
</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://blog.lemongame.top/undefined/消息机制/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="疯狂小柠檬">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Lemon's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/undefined/消息机制/" itemprop="url">消息机制</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-08-27T18:02:04+08:00">
                2019-08-27
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="消息机制"><a href="#消息机制" class="headerlink" title="消息机制"></a>消息机制</h3><h4 id="方法定义"><a href="#方法定义" class="headerlink" title="方法定义"></a>方法定义</h4><p>Runtime中的方法定义为:</p>
<pre><code>struct objc_method {
  SEL method_name                                          OBJC2_UNAVAILABLE;
  char *method_types                                       OBJC2_UNAVAILABLE;
  IMP method_imp                                           OBJC2_UNAVAILABLE;
}  OBJC2_UNAVAILABLE;</code></pre><h4 id="SEL"><a href="#SEL" class="headerlink" title="SEL"></a>SEL</h4><p>SEL是根据方法的名称哈希化的一个值，相当于是一个方法的映射，或者说是方法的签名，我们可以根据这个值，找到对应的方法。只要方法名称相同，其值就是唯一的，因此在同一个类或者有继承关系的类中不能有相同的方法名，这也是OC不支持方法重载的原因。我们可以用@selector()来获取这个值。</p>
<p>SEL的存在，是为了加快方法的查询速度，省去了字符串(即方法名)比对的时间，可以直接用SEL生成的KEY去查找，这样效率更高，就像我们直接根据NSDictionary的Key去读取相应的值一样。</p>
<h4 id="IMP"><a href="#IMP" class="headerlink" title="IMP"></a>IMP</h4><p>IMP是一个指向函数的指针，其代表方法实现函数的入口地址，得到这个值，就找到了方法实现的入口。runtime 通过SEL找到IMP，进而实现方法调用的。</p>
<h4 id="OC方法调用"><a href="#OC方法调用" class="headerlink" title="OC方法调用"></a>OC方法调用</h4><p>OC中的方法调用，其实是通过消息来传递的，我们甚至可以把方法叫做消息。</p>
<p>当我们在调用[Object message]时，runtime做了以下处理：</p>
<ol>
<li>将这个方法调用转换成objc_msgSend函数</li>
<li>objc_msgSend函数会根据Object的isa指针，找到其所属的类，然后在其类中的方法列表中查找这个message对应的selector，</li>
<li>如果没有找到，objc_msgSend会根据Object的superclass指针，找到该对象所属类的父类，然后在父类的方法列表中查找message对应的selector，依此，objc_msgSend会在类的继承结构中一直向上寻找，直到到达NSObject类。</li>
<li>一旦定位到selector.函数就会传入方法的接收者及其他所需要的参数，从而调用这个方法的实现。</li>
</ol>
<p>如果直到NSObject类中，还么有找到方法的实现IMP,那么runtime会进入消息转发流程</p>
<h3 id="消息转发"><a href="#消息转发" class="headerlink" title="消息转发"></a>消息转发</h3><p>如下图:</p>
<p><img src="https://raw.githubusercontent.com/xuehan111/images/master/%E6%B6%88%E6%81%AF%E8%BD%AC%E5%8F%91.png" alt="消息转发"></p>
<p>如果直到NSObject类，仍然没有找到方法的实现，那么系统会去看我们是否是动态实现了该方法.<br>如果是实例方法，会调用对象所在类的</p>
<pre><code>+ (BOOL)resolveInstanceMethod:(SEL)sel</code></pre><p> 如果是类方法，会调用 </p>
<pre><code>+ (BOOL)resolveClassMethod:(SEL)sel。</code></pre><p>  代码示例：</p>
<p>Person.h</p>
<pre><code>#import &lt;Foundation/Foundation.h&gt;
@interface Person : NSObject
@end</code></pre><p> Person.m</p>
<pre><code>#import &quot;Person.h&quot;
#import &lt;objc/runtime.h&gt;

void setNameImp(id self, SEL _cmd, NSString *name){
    NSLog(@&quot;%@&quot;,name);
}

@implementation Person

+ (BOOL)resolveInstanceMethod:(SEL)sel{
    NSLog(@&quot;%s&quot;,__FUNCTION__);
    if(sel == @selector(setName:)){
        class_addMethod(self, sel, (IMP)setNameImp, &quot;v@:@&quot;);
        return YES;
    }
    return [super resolveInstanceMethod:sel];
}
@end</code></pre><p>main.m</p>
<pre><code>#import &lt;Foundation/Foundation.h&gt;
#import &quot;Person.h&quot;

int main(int argc, const char * argv[]) {
  @autoreleasepool {
    Person *p = [[Person alloc] init];
    [p performSelector:@selector(setName:) withObject:@&quot;百客&quot;];
  }
  return 0;
}</code></pre><p> 输出结果：</p>
<pre><code>+[Person resolveInstanceMethod:]
百客</code></pre><p>如果动态方法解析时，没有处理传递的消息，那么系统就会走转发流程。<strong>动态解析的两个方法是在消息转发前执行的，如果想跳过动态解析过程，直接走消息转发流程，直接将两个方法的返回值设为NO</strong></p>
<h4 id="Message-Forwarding"><a href="#Message-Forwarding" class="headerlink" title="Message Forwarding"></a>Message Forwarding</h4><p>运行时，如果走到了转发流程阶段，系统会先判断是否转移了消息的接收者。</p>
<ol>
<li><p>转移消息的接收者<br>通过</p>
<pre><code>- forwardingTargetForSelector:</code></pre><p>可以转移消息的接收者，如果有别的对象可以实现该方法，就直接让那个对象来处理该消息。<strong>不管另一对象的方法是公有还是私有，只要实现了就行</strong></p>
<pre><code>- (id)forwardingTargetForSelector:(SEL)aSelector{
  if(@selector(setName:) == aSelector){
     Student *s = [[Student alloc] init];
     return s;
  }
  return [super forwardingTargetForSelector:aSelector];
 }      </code></pre><p>   Student.m</p>
<pre><code>#import &quot;Student.h&quot;

@implementation Student
- (void)setName:(NSString *)name{
  NSLog(@&quot;%@--&quot;,name);
}
@end</code></pre><p><strong>Note:该方式只是转移消息的接受者，不能对传递的消息做修改。</strong></p>
</li>
<li><p>完整转发<br>如果上述方式没有对转发的消息做处理，那么系统就会走完整的转发流程。<br>系统会先通过 </p>
<pre><code>- (NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector</code></pre><p>方法，找到最终响应传递的消息的方法的地址，然后再通过</p>
<pre><code>- (void)forwardInvocation:(NSInvocation *)anInvocation</code></pre><p>来转发消息。如果通过第一个方法没有找到最终响应消息的方法的地址，第二个方法是不会执行的。</p>
<p><strong>通过这种方式转发的消息，我们不仅可以转换消息的接收者，还可以对转发的消息做相应的修改。</strong></p>
</li>
</ol>
<p>继续上面的代码，我们在Person.m中增加了如下代码，main.m中的代码没有做改动。</p>
<p>  Person.m</p>
<pre><code>- (void)forwardInvocation:(NSInvocation *)anInvocation{
   NSString *name = @&quot;hello&quot;;
   int age = 10;
   [anInvocation setArgument:&amp;name atIndex:2];
   [anInvocation setArgument:&amp;age atIndex:3];
   anInvocation.selector = @selector(setName:age:);                  
   Student *s = [[Student alloc] init];
   if([s respondsToSelector:[anInvocation selector]]){
     [anInvocation invokeWithTarget:s];
   }else{
     [super forwardInvocation:anInvocation];
   }
 }

- (NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector{
    NSMethodSignature *sign = [super methodSignatureForSelector:aSelector];
    if(!sign){
       Student *s = [[Student alloc] init];
       sign = [s methodSignatureForSelector:@selector(setName:age:)];
     }
    return sign;
 }</code></pre><p>在代码中，我们将转发给Person对象的setName消息，转发给了Student对象，并修改了消息的内容，最终<br>输出结果如下:</p>
<pre><code>hello--10</code></pre><p>在代码中，我们将转发给Person对象的setName消息，转发给了Student对象，并修改了消息的内容，最终<br>输出结果如下:</p>
<p>hello–10</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://blog.lemongame.top/undefined/类的本质/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="疯狂小柠檬">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Lemon's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/undefined/类的本质/" itemprop="url">类的本质</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-08-27T17:36:01+08:00">
                2019-08-27
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="揭秘类的本质"><a href="#揭秘类的本质" class="headerlink" title="揭秘类的本质"></a>揭秘类的本质</h3><p>OC中的类是由Class来定义的，其实际上就是一个指向objc_class结构体的指针，其定义为</p>
<pre><code>typedef struct objc_class *Class;</code></pre><p>而objc_class又是什么样的呢，查看其定义为</p>
<pre><code>struct objc_class {
    Class isa  OBJC_ISA_AVAILABILITY;
    #if !__OBJC2__
    Class super_class         OBJC2_UNAVAILABLE;  // 父类
    const char *name          OBJC2_UNAVAILABLE;  // 类名
    long version              OBJC2_UNAVAILABLE;  // 类的版本号
    long info                OBJC2_UNAVAILABLE;  // 类信息
    long instance_size      OBJC2_UNAVAILABLE;  // 类的实例大小
    struct objc_ivar_list *ivars            OBJC2_UNAVAILABLE;  // 成员变量列表
    struct objc_method_list **methodLists   OBJC2_UNAVAILABLE;  // 方法列表
    struct objc_cache *cache                OBJC2_UNAVAILABLE;  // 方法缓存
    struct objc_protocol_list *protocols    OBJC2_UNAVAILABLE;  // 协议列表
    #endif
} OBJC2_UNAVAILABLE;</code></pre><h4 id="对象-id"><a href="#对象-id" class="headerlink" title="对象(id)"></a>对象(id)</h4><p>OC中的万能对象用id来表示，其实际上就是一个指向 objc_object 结构体的指针，其定义如下：</p>
<pre><code>typedef struct objc_object *id;</code></pre><p>objc_object 的定义为 </p>
<pre><code>struct objc_object {
    Class isa  OBJC_ISA_AVAILABILITY;
};</code></pre><h4 id="isa"><a href="#isa" class="headerlink" title="isa"></a>isa</h4><p>由类和对象的定义，我们可以看出，其成员变量中都含有isa指针，isa指向的是一个类，其指向该对象所属的类。我们可以把isa当作是一个对象的标志，因此类也是一个对象，我们称之为类对象，其isa指针，指向该类对象所属的类，我们称之为元类(metaClass)。</p>
<p>isa指针指向的类，我们可以用[object class]来获取，但是，如果是类对象，其只能返回当前类，获取不到元类。object_getClass()函数也可以获取到isa指针指向的类，包括元类。</p>
<p>下面是class方法和object_getClass()函数的具体实现。</p>
<pre><code>- (Class)class {
    return object_getClass(self);
}
+ (Class)class {
    return self;
}
Class object_getClass(id obj)
{
    if (obj) return obj-&gt;getIsa();
    else return Nil;
}</code></pre><p>那么isa，类，父类，元类之间的关系又是怎样的？由于元类无法打印出来，因此我们采用查看其地址的方法来探究其关系。</p>
<p>先看代码：</p>
<pre><code>#import &lt;Foundation/Foundation.h&gt;

@interface Person: NSObject
@end;
@interface Student: Person
@end;

int main(int argc, const char * argv[]) {

    @autoreleasepool {

        Person *p = [[Person alloc] init];
        Student *s = [[Student alloc] init];

        NSLog(@&quot;对象 s --&gt; isa 指向地址是 %p&quot;,[s class]);
        NSLog(@&quot;Student --&gt; isa 指向地址是 %p&quot;,object_getClass([Student class]));
        NSLog(@&quot;Student --&gt; isa --&gt; isa 指向的地址是 %p&quot;,object_getClass(object_getClass([Student class])));
        NSLog(@&quot;Student --&gt; isa --&gt; superclass  的地址是 %p&quot;,[object_getClass([Student class]) superclass]);
        NSLog(@&quot;s --&gt; superclass 的地址 %p&quot;,[s superclass]);

        NSLog(@&quot;============================&quot;);

        NSLog(@&quot;对象 p --&gt; isa 指向的地址是 %p&quot;,[p class]);
        NSLog(@&quot;Person --&gt; isa 指向的地址是 %p&quot;,object_getClass([Person class]));
        NSLog(@&quot;Person --&gt; isa --&gt; isa 指向的地址是 %p&quot;,object_getClass(object_getClass([Person class])));
        NSLog(@&quot;Person --&gt; isa --&gt; superclass 的地址是 %p&quot;,[object_getClass([Person class]) superclass]);
        NSLog(@&quot;p --&gt; superclass 的地址 %p&quot;,[p superclass]);

        NSLog(@&quot;============================&quot;);


        NSLog(@&quot;NSObject 的地址 %p&quot;,[NSObject class]);
        NSLog(@&quot;NSObject --&gt; isa 的地址是 %p&quot;,object_getClass([NSObject class]));
        NSLog(@&quot;NSObject --&gt; isa --&gt; isa 的地址是 %p&quot;,object_getClass(object_getClass([NSObject class])));
        NSLog(@&quot;NSObject --&gt; isa --&gt; superclass 的地址是 %p&quot;,[object_getClass([NSObject class]) superclass]);

        NSLog(@&quot;NSObject --&gt; superclass 的地址 %p&quot;,[NSObject superclass]);  
    }
    return 0;
}

输出结果：

对象 s --&gt; isa 指向地址是 0x1000049a0
Student --&gt; isa 指向地址是 0x100004978
Student --&gt; isa --&gt; isa 指向的地址是 0x7fff7f835118
Student --&gt; isa --&gt; superclass  的地址是 0x100004928
s --&gt; superclass 的地址 0x100004950
============================
对象 p --&gt; isa 指向的地址是 0x100004950
Person --&gt; isa 指向的地址是 0x100004928
Person --&gt; isa --&gt; isa 指向的地址是 0x7fff7f835118
Person --&gt; isa --&gt; superclass 的地址是 0x7fff7f835118
p --&gt; superclass 的地址 0x7fff7f8350f0
============================
NSObject 的地址 0x7fff7f8350f0
NSObject --&gt; isa 的地址是 0x7fff7f835118
NSObject --&gt; isa --&gt; isa 的地址是 0x7fff7f835118
NSObject --&gt; isa --&gt; superclass 的地址是 0x7fff7f8350f0
NSObject --&gt; superclass 的地址 0x0</code></pre><p>得到关系图如下：<br><img src="https://raw.githubusercontent.com/xuehan111/images/master/%E7%B1%BB%E5%85%B3%E7%B3%BB.png" alt="类关系"></p>
<p><strong>由图我们可以得出以下结论：</strong></p>
<ul>
<li>实例对象的isa指向该对象所属的类</li>
<li>类对象的isa指向该类对象所属的类，即元类(metaclass)</li>
<li>元类的isa指向该类对象的顶级父类(NSObject)的元类</li>
<li>类对象的元类的superclass指向该类对象的父类的元类</li>
<li>顶级类对象(NSObject)的元类的isa指向元类自己</li>
<li>顶级类对象的superclass指向nil(0x0)</li>
</ul>
<h3 id="类关系应用示例"><a href="#类关系应用示例" class="headerlink" title="类关系应用示例"></a>类关系应用示例</h3><pre><code>@interface Person: NSObject
@end;

int main(int argc, const char * argv[]) {

    @autoreleasepool {
        Person *p = [[Person alloc] init];

        BOOL isEqual = [p isKindOfClass:[Person class]]; 
        BOOL isEqual1 = [Person isKindOfClass:[Person class]]; 
        BOOL isEqual2 = [NSObject isKindOfClass:[NSObject class]]; 

        BOOL isEqual3 = [p isMemberOfClass:[Person class]]; 
        BOOL isEqual4 = [Person isMemberOfClass:[Person class]]; 
        BOOL isEqual5 = [NSObject isMemberOfClass:[NSObject class]]; 

        NSLog(@&quot;%d %d %d %d %d %d&quot;,isEqual,isEqual1,isEqual2,isEqual3,isEqual4,isEqual5);

    }
    return 0;
}</code></pre><p>输出结果是怎样的呢？<br>运行后，我们看到结果是：</p>
<pre><code>1 0 1 1 0 0</code></pre><p>为什么结果是这样的呢？我们先来看isKindOfClass:和isMemberOfClass:这两个方法是怎么实现的。</p>
<pre><code>NSObject.mm

+ (BOOL)isKindOfClass:(Class)cls {
    for (Class tcls = object_getClass((id)self); tcls; tcls = tcls-&gt;superclass) {
    if (tcls == cls) return YES;
    }
    return NO;    
}
- (BOOL)isKindOfClass:(Class)cls {
    for (Class tcls = [self class]; tcls; tcls = tcls-&gt;superclass) {
    if (tcls == cls) return YES;
    }
    return NO;
}
+ (BOOL)isMemberOfClass:(Class)cls {
    return object_getClass((id)self) == cls;
}
- (BOOL)isMemberOfClass:(Class)cls {
    return [self class] == cls;
}</code></pre><p>不难发现，这两个方法，都是用对象的isa，去和参数cls做比较，所不同的是，如果第一次比较，两者不相同，isKindOfClass:会去寻找isa的superclass，如果一直比较到最顶层的superclas（nil），仍然没有找到相同的，才返回NO。</p>
<p><strong>下面来看isEqual1的比较过程：</strong></p>
<p>第一次: Person的metaClass 和 Person相比 ＝＝ NO<br>第二次：Person的metaClass的superclass即NSObject的metaClass 和 Person相比 ＝＝ NO<br>第三次：NSObject的metaClass的superclass 和 Person相比 ＝＝ NO<br>最后：Person 的superClass ＝＝ nil，退出比较，直接返回NO</p>
<p>isEqual2的比较过程：</p>
<p>第一次: NSObject的metaClass 和 NSObject相比 ＝＝ NO<br>第二次：NSObject的metaClass的superclass 即NSObject 和 NSObject相比 ＝＝ YES<br>最后，退出比较，返回YES</p>
<p>其他的比较类似，这里不做累述。</p>
<h3 id="动态创建类"><a href="#动态创建类" class="headerlink" title="动态创建类"></a>动态创建类</h3><p>说了这么多，我们来动态创建个类，在动态创建之前，先介绍几个函数：</p>
<ul>
<li><p>objc_allocateClassPair(Class superclass, const char *name, size_t extraBytes)<br>该方法用来动态创建一个类，<br>superclass：为要创建的类的父类,如果传nil，则表示要创建根类。<br>name: 要创建的新类<br>extraBytes： 分配给类和元类尾部索引变量的字节数，通常为0</p>
</li>
<li><p>void objc_disposeClassPair(Class cls)<br>该方法用于销毁一个类和其关联的元类，注意:如果该类的实例或其任何一个子类存在的时候，不要调用该方法。</p>
</li>
<li><p>void objc_registerClassPair(Class cls)<br>注册一个类</p>
</li>
<li><p>BOOL class_addMethod(Class cls, SEL name, IMP imp, const char *types)<br>给类动态添加方法<br>name: 要增加的方法名称的映射<br>imp：方法的实现，该方法必须至少包含两个参数，self 和 _cmd<br>types: 类型编码，用一个C字符串来表示方法的返回值和参数，列举几个常用的类型编码：</p>
</li>
</ul>
<table>
<thead>
<tr>
<th align="center">Code</th>
<th align="center">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="center">v</td>
<td align="center">表示void</td>
</tr>
<tr>
<td align="center">@</td>
<td align="center">表示一个对象</td>
</tr>
<tr>
<td align="center">:</td>
<td align="center">表示一个方法选择器 SEL</td>
</tr>
</tbody></table>
<p>由于方法的实现必须包含self和_cmd两个参数，因此types的第二个和第三个字符必须是”@:”（第一个是返回值类型）</p>
<ul>
<li>BOOL class_addIvar(Class cls, const char *name, size_t size, uint8_t alignment, const char *types)<br>给类添加成员变量, 该方法只能在动态创建类的时候使用，不能向已存在的类中添加成员变量<br>cls: 要添加成员变量的类，该类不能是元类<br>name: 变量名称<br>size：变量类型大小，通常可用sizeof来获取<br>alignment: 偏移量，实例变量的最小偏移量是1&lt;&lt;align，如果是指针类型，我们可以传log2(sizeof(pointer_type)).</li>
</ul>
<p>size和alignment我们也可以通过如下方式来得到，如<br>NSUInteger size;<br>NSUInteger alignment;<br>NSGetSizeAndAlignment(“*”, &amp;size, &amp;alignment);</p>
<p>types: 类型编码。</p>
<p><strong>动态创建的类必须从objc_allocateClassPair开始，直到 class_addMethod、 class_addIvar等方法都执行完之后，最后再用objc_registerClassPair注册该类。</strong></p>
<p>代码实践<br>本例子动态创建了一个类，并向其中添加了方法和成员变量，最后，执行了新添加的方法并获取了新添加的变量的值。</p>
<pre><code>#import &lt;Foundation/Foundation.h&gt;
#import &lt;objc/runtime.h&gt;

void myMethodIMP(id self, SEL _cmd)
{
NSLog(@&quot;我是新类----%@&quot;,[self class]);
}

int main(int argc, const char * argv[]) {

    @autoreleasepool {

        Class cls =  objc_allocateClassPair([NSObject class],&quot;myClass&quot;, 0);
        class_addMethod(cls, NSSelectorFromString(@&quot;myMethodIMP&quot;),(IMP)myMethodIMP, &quot;v@:&quot;);
        BOOL flag = class_addIvar(cls, &quot;name&quot;, sizeof(NSString *), log2(sizeof(NSString *)), &quot;@&quot;);
        objc_registerClassPair(cls);

        id instance = [[cls alloc] init];
        [instance setValue:@&quot;小白&quot; forKey:@&quot;name&quot;]; // 这里用kvc的时候，最好判断下该变量是否存在，或者用下面的这种方法
        //        object_setIvar(instance, class_getInstanceVariable(cls, &quot;_age&quot;), @&quot;10&quot;);
        [instance performSelector:@selector(myMethodIMP)];

        Ivar v = class_getInstanceVariable(cls, &quot;name&quot;);
        id o = object_getIvar(instance, v);

        NSLog(@&quot;动态添加的成员变量name的值为---%@&quot;,o);

    }
    return 0;
}</code></pre><p>输出结果：</p>
<pre><code>我是新类----myClass
动态添加的成员变量name的值为---小白</code></pre>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/images/avatar.gif" alt="疯狂小柠檬">
            
              <p class="site-author-name" itemprop="name">疯狂小柠檬</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives">
              
                  <span class="site-state-item-count">17</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            

            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; 2015 &mdash; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">疯狂小柠檬</span>

  
</div>









        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.3"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.3"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.3"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
