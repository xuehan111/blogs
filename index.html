<!DOCTYPE html>



  


<html class="theme-next mist use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.3" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png?v=5.1.3">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32.png?v=5.1.3">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16.png?v=5.1.3">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.3" color="#222">





  <meta name="keywords" content="Hexo, NexT">










<meta property="og:type" content="website">
<meta property="og:title" content="Lemon&#39;s Blog">
<meta property="og:url" content="https://blog.lemongame.top/index.html">
<meta property="og:site_name" content="Lemon&#39;s Blog">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Lemon&#39;s Blog">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    version: '5.1.3',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://blog.lemongame.top/">





  <title>Lemon's Blog</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta custom-logo">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Lemon's Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-首页">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-标签">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-分类">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-归档">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-关于">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br>
            
            关于
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://blog.lemongame.top/undefined/iOS-Sign/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="疯狂小柠檬">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Lemon's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/undefined/iOS-Sign/" itemprop="url">iOS签名机制</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-08-27T18:59:27+08:00">
                2019-08-27
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="iOS-App签名机制"><a href="#iOS-App签名机制" class="headerlink" title="iOS App签名机制"></a>iOS App签名机制</h3><p>流程图如下:<br><img src="https://raw.githubusercontent.com/xuehan111/images/master/app_sign.png" alt="app_sign.png"></p>
<h4 id="实际操作流程"><a href="#实际操作流程" class="headerlink" title="实际操作流程"></a>实际操作流程</h4><p>1、在<code>keychain</code>里从 证书颁发机构请求证书。此时，便在本地生成了一对公私钥(公钥L,私钥L)，我们得到的<code>certSigningRequest</code>文件即是公钥L，私钥L保存在我们的本地电脑里。</p>
<p>2、将<code>certSigningRequest</code>文件传到Apple后台，Apple用自己的私钥A对这个文件进行签名，得到开发证书。将该证书下载到本地。<br>这时本地有两个证书，一个是第1步生成的，一个是这里下载回来的，keychain会把这两个证书关联起来，因为它们的公私钥是对应的，在Xcode选择下载回来的证书时，实际上会找到keychain里面对应的私钥L去签名。这里私钥L只有生成它的这台Mac才有，如果别的Mac也要编译签名这个App，怎么办？答案是把私钥导出给其他Mac使用，在keychain里面导出私钥，就会存成.p12文件，其他Mac打开后就导入私钥。</p>
<p>3、在苹果后台配置AppID、App使用权限、设备ID列表等。加上第2步的cer证书，组成的数据用私钥A进行签名，把数据和签名一起组成一个描述文件Provisioning Profile，将其下载到Mac本机。</p>
<p>4、开发时，Xcode会通过第2步下载回来的cer证书(存着本地公钥L)，在本地找到对应的私钥L(第1步生成的)，然后用私钥L去签名App，并把Provisioning Profile文件命名为embedded.mobileprovision一起打包到App中。这里对App的签名数据保存分为两部分，Mach-O可执行文件会把签名直接写入这个文件里，其他资源文件则会保存在_CodeSignature目录下</p>
<p>5、安装时，iOS系统取得证书，通过系统内置的公钥A，去验证 embedded.mobileprovision的数字签名是否正确，里面的证书签名也会再验一遍。</p>
<p>6、确保了embedded.mobileprovision里的数据都是苹果授权以后，就可以取出里面的数据，做各种验证，包括用公钥L验证APP签名，验证设备ID是否在ID列表上，AppID是否对应得上，权限开关是否跟APP里的Entitlements对应等。</p>
<pre><code>Note: 

证书：内容是公钥或私钥，由其他机构对其签名组成的数据包。
Entitlements：包含了App权限开关列表。
CertificateSigningRequest：本地公钥。
.p12：本地私钥，可以导入到其他电脑。
Provisioning Profile：包含了 证书/Entitlements 等数据，并由苹果后台私钥签名的数据包。</code></pre><h3 id="Question-amp-amp-Answer"><a href="#Question-amp-amp-Answer" class="headerlink" title="Question &amp;&amp; Answer"></a>Question &amp;&amp; Answer</h3><p><strong>Q1、为什么团队开发，真机调试需要 p12 文件？</strong></p>
<p>在Xcode选择下载回来的cer证书时，实际上会找到keychain里面对应的私钥L去签名。这个私钥L只有生成它的这台Mac才有，如果别的Mac也要编译签名这个App，则需要把私钥L导出给其他Mac使用，在keychain里面导出第二步下载安装的cer文件，就会存成.p12文件，其含有私钥L，其他Mac打开后就导入私钥。</p>
<p><strong>Q2、为什么证书过期了，AppStore发布的app还可以正常使用？</strong></p>
<p>因为上传到AppStore的ipa，苹果会重新对内容加密，原来的本地私钥L签名就没有用了，需要重新签名，从AppStore下载的包苹果也并不打算控制它的有效期，不需要内置一个embedded.mobileprovision去做校验，直接在苹果用后台的私钥A重新签名，iOS安装时用本地公钥A验证App签名就可以了。</p>
<p><strong>Q3、既然发布后的App不需要各种证书，为什么发布AppStore的包还是要跟开发版一样搞各种证书和Provisioning Profile？</strong></p>
<p>猜测因为苹果想做统一管理，Provisioning Profile里包含一些权限控制，AppID 的检验等，苹果不想在上传AppStore 包时重新用另一种协议做一遍这些验证，就不如统一把这部分放在 Provisioning Profile里，上传AppStore时只要用同样的流程验证这个 Provisioning Profile是否合法就可以了</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://blog.lemongame.top/undefined/git/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="疯狂小柠檬">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Lemon's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/undefined/git/" itemprop="url">git存储原理</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-07-16T18:53:38+08:00">
                2019-07-16
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="git存储原理"><a href="#git存储原理" class="headerlink" title="git存储原理"></a>git存储原理</h3><h4 id="git流程图"><a href="#git流程图" class="headerlink" title="git流程图"></a>git流程图</h4><p>git的大致流程图入下:</p>
<p><img src="https://raw.githubusercontent.com/xuehan111/images/master/git%E6%B5%81%E7%A8%8B%E5%9B%BE.png" alt="git流程图.png"></p>
<ul>
<li>Workspace：工作区</li>
<li>Index / Stage：暂存区</li>
<li>Repository：本地仓库</li>
<li>Remote：远程仓库</li>
</ul>
<p>1.Workspace 工作区</p>
<p>正在编辑的文件状态。该区域下的下的文件状态为未跟踪（untrack）状态。</p>
<p>通过git pull把远程仓库中的文件同步到工作区</p>
<p>2.Index/Stage 暂存区</p>
<p>保存了下次将提交的文件列表信息。该区域的文件状态为已暂存状态。</p>
<p>通过git add把Workspace区域中的文件提交到暂存区中</p>
<p>3.Repository 本地仓库</p>
<p>本地仓库就是从服务器上复制到本地的一份代码，所做的操作都是对这个仓库发生的。</p>
<p>通过git commit把文件提交到本地仓库中。</p>
<p>4.远程仓库</p>
<p>远程仓库也就是我们所说的服务器端，最终，我们需要将本地仓库中的改动同步到远程仓库。</p>
<p>通过git push把本地仓库中的文件推送到远程仓库中。</p>
<h4 id="git内部原理详解"><a href="#git内部原理详解" class="headerlink" title="git内部原理详解"></a>git内部原理详解</h4><p>git内部存储数据有三种对象类型：blob对象、commit对象、tree对象。其都存储在.git文件夹下的objects下。git使用文件内容+特定头部信息一起的SHA-1 校验和为文件命名，校验和的前两个字符用于命名子目录，余下的 38 个字符则用作文件名。</p>
<p><img src="https://raw.githubusercontent.com/xuehan111/images/master/git_objects.jpg" alt="git_objects.jpg"></p>
<ul>
<li><p>blob对象</p>
<p>这是git存储文件内容的方式。每一个文件都会对应一个blob对象。我们对同一个文件的每次add 操作，即添加到暂存区，都会生成一个新blob对象。</p>
<p>我们初始化个git项目: git init Demo</p>
<p><img src="https://raw.githubusercontent.com/xuehan111/images/master/git_init.jpg" alt="git_init"></p>
<p>我们会发现git已经帮我们生成了objects文件夹，并且该文件夹下包含info和pack空文件夹。因为我们还么有向Dmeo中添加文件，所以objects文件夹下，并么有blob对象。我们向项目Demo中添加个文件</p>
<pre><code>$ echo &quot;a&quot; &gt;&gt; a.txt
 $ git add a.txt</code></pre><p>执行后发现objects文件夹下多了个文件夹，其文件夹名称加上子文件的名称就是a.txt对应的blob对象的sha-1校验和, 78981922613b2afb6025042ff6bd878ac1994e85</p>
<p> <img src="https://raw.githubusercontent.com/xuehan111/images/master/git_addfile.jpg" alt="git_addfile.jpg">;</p>
<p> 我们可以使用 <code>git cat-file -t sha-1值</code> 来查看文件类型</p>
<pre><code> $ git cat-file -t 78981922613b2afb6025042ff6bd878ac1994e85

执行后，输出

    blob</code></pre><p>我们对a.txt 做下修改:</p>
<pre><code>$ echo &quot;aaa&quot; &gt;&gt; a.txt
$ git add a.txt</code></pre><p>此时，objects文件夹下多了个文件夹cd,其对应我们修改后的blob对象:</p>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/xuehan111/images/master/git_changefile.jpg" alt="git_changefile.jpg"></p>
<p>  虽然我们修改的是同一个文件a.txt，但是git对我们每一次的修改都生成了一个blob文件。</p>
<ul>
<li><p>Tree 对象</p>
<p>  blob对象，对应我们项目中的文件，而tree对象对应项目中的目录，即文件夹。一个Tree对象包含了一条或多条Tree对象记录，每条记录含有一个指向blob对象或者子tree对象的 SHA-1 指针，以及相应的模式、类型、文件名信息。</p>
<p>  我们对刚才的项目做下改动:<br>  <img src="https://raw.githubusercontent.com/xuehan111/images/master/git_tree0.jpg" alt="git_tree0.jpg"></p>
<p>  执行 <code>git add .</code>将改动添加到暂存区。 通常，Git 根据某一时刻暂存区（即 index 区域）所表示的状态创建并记录一个对应的树对象。我们可以可以通过 <code>write-tree</code> 命令将暂存区内容写入一个树对象.然后观察它的结构:</p>
<pre><code>$ git write-tree
d48fb57270ffcedfa7a9bce975c3883b531e3f73
$ git cat-file -p d48fb57270ffcedfa7a9bce975c3883b531e3f73
100644 blob 3cadea260b677e4265363400d2dd6bd2f950d4bf    README.md
100644 blob cd974dc3ea825c2145d68606da683dd0532d7b6e    a.txt
040000 tree f8f7aefc2900a3d737cea9eee45729fd55761e1a    lib
$ git cat-file -p f8f7aefc2900a3d737cea9eee45729fd55761e1a
100644 blob 61780798228d17af2d34fce4cfbdf35556832472    b.txt</code></pre><p>  可以看出，项目的tree结构是这样的:</p>
<p>  <img src="https://raw.githubusercontent.com/xuehan111/images/master/git_tree.png" alt="git_tree.png"></p>
</li>
<li><p>Commit 对象    </p>
<p>  当我们在执行<code>git commit</code>操作的时候，git会将暂存区的状态，记录成对应的树对象，并且创建一个commit对象来记录当前树的信息。</p>
<p>  我们可以提交一下，然后用命令 来查看提交信息</p>
<pre><code>$ git commit -m &quot;第一次提交&quot;

[master (root-commit) d320bb7] 第一次提交
3 files changed, 4 insertions(+)
create mode 100644 README.md
create mode 100644 a.txt
create mode 100644 lib/b.txt</code></pre><p>  查看提交日志</p>
<pre><code>$ git log

commit d320bb785006e604d3b7072a532cae78a37142f6 (HEAD -&gt; master)
Author: xiaobai &lt;madd@smartoven.tech&gt;
Date:   Wed Jun 12 14:13:29 2019 +0800

第一次提交</code></pre><p>  查看提交对象:</p>
<pre><code>$ git cat-file -p d320bb
tree d48fb57270ffcedfa7a9bce975c3883b531e3f73
author xiaobai &lt;madd@smartoven.tech&gt; 1560320009 +0800
committer xiaobai &lt;madd@smartoven.tech&gt; 1560320009 +0800

第一次提交</code></pre><p>  可以看到:</p>
<p>  <strong>提交对象的格式很简单：它先指定一个顶层tree对象(d48fb5)，代表当前项目快照；然后是作者/提交者信息（依据你的 user.name 和 user.email 配置来设定，外加一个时间戳）；留空一行，最后是提交注释。</strong></p>
<p>  <strong>另外有个信息，我们么有看到，就是每一个commit对象都有一个指针指向其父commit对象(上一次提交的commit对象)</strong></p>
</li>
<li><p>小结: </p>
<p>  <strong>以上是每次我们运行 git add 和 git commit 命令时， Git 所做的实质工作——将被改写的文件保存为数据对象，更新暂存区，记录树对象，最后创建一个指明了顶层树对象和父提交的提交对象。 这三种主要的 Git 对象——数据对象、树对象、提交对象——最终均以单独文件的形式保存在 .git/objects 目录下</strong></p>
</li>
</ul>
<h4 id="git分支"><a href="#git分支" class="headerlink" title="git分支"></a>git分支</h4><p>在项目初始化的时候，我们可以看到 .git 文件夹下有个HEAD文件:</p>
<p> HEAD 文件是一个符号引用，指向当前所在的分支。 所谓符号引用，意味着它并不像普通引用那样包含一个 SHA-1 值——它是一个指向其他引用的指针。</p>
<p> 当我们执行 git commit 时，该命令会创建一个提交对象，并用 HEAD 文件中那个引用所指向的 SHA-1 值设置其父提交字段</p>
<p> 另外我们还可以看到 .git 文件夹下有个refs文件夹，其子文件heads存放着每一个分支的最后一次提交时的commit对象的 sha-1值。<br> <img src="https://raw.githubusercontent.com/xuehan111/images/master/git_refs.jpg" alt="git_refs.jpg"></p>
<p>  git 分支的本质其实就是一个指向某一系列提交之首的指针或引用。当我们创建分支的时候，git会在refs文件夹下的heads文件夹中新建一个分支引用文件，然后根据HEAD文件，找到当前分支的最后一次提交commit对象的 sha-1值，写入这个分支引用文件中，之后的每次提交，都会更新这个分支引用文件为最新的提交commit对象的 sha-1值。</p>
<p>  git分支的切换，其实就是根据refs下的heads文件夹，找到分支的引用，然后根据分支引用中的commit对象来读取数据，同时，修改HEAD中的值为当前分支。</p>
<p>  git分支的切换.如图</p>
<p>  <img src="https://raw.githubusercontent.com/xuehan111/images/master/git_merge.png" alt="git_merge.png"></p>
<p>  Branch 1 和 Branch 2分支进行mrege的时候，会根据C3、C4、找到这个提交的共同祖先C1，然后进行三方合并，并把合并结果重新做一个新的快照，并自动创建一个指向它的提交对象（C5）<br>  <img src="https://raw.githubusercontent.com/xuehan111/images/master/git_merge_result.png" alt="git_merge_result.png"></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://blog.lemongame.top/undefined/git命令/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="疯狂小柠檬">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Lemon's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/undefined/git命令/" itemprop="url">git命令</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-07-16T17:57:36+08:00">
                2019-07-16
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="git命令"><a href="#git命令" class="headerlink" title="git命令"></a>git命令</h3><ul>
<li>git hash-object -w 文件名</li>
</ul>
<p>存储数据对象,输出一个长度为 40 个字符的校验和。 这是一个 SHA-1 哈希值——一个将待存储的数据外加一个头部信息（header）一起做 SHA-1 校验运算而得的校验和</p>
<ul>
<li><p>git cat-file -p SHA-1值</p>
<p>查看文件内容</p>
</li>
<li><p>git cat-file -t SHA-1值</p>
<p>  查看git内部存储文件的对象类型</p>
</li>
<li><p>git cat-file -p 分支名称^{tree}</p>
<p>  查看指定分支的树结构</p>
</li>
<li><p>git update-index –add –cacheinfo 100644 \</p>
<p>创建一个暂存区，并将文件添加到暂存区。</p>
<p>100644:表明这是一个普通文件</p>
<p>100755:表示一个可执行文件</p>
<p>120000:表示一个符号链接</p>
</li>
<li><p>git write-tree</p>
<p>  将暂存区内容写入一个树对象</p>
</li>
<li><p>git update-ref refs/heads/newbranch commit的sha值</p>
<p>  更新分支引用，相当于创建了 newbranch 分支。</p>
<p>  当运行类似于 git branch (branchname) 这样的命令时，Git 实际上会运行 update-ref 命令，取得当前所在分支最新提交对应的 SHA-1 值，并将其加入你想要创建的任何新引用中</p>
</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://blog.lemongame.top/undefined/block/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="疯狂小柠檬">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Lemon's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/undefined/block/" itemprop="url">block</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-06-19T20:42:23+08:00">
                2019-06-19
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="深入理解block"><a href="#深入理解block" class="headerlink" title="深入理解block"></a>深入理解block</h3><h4 id="Block的使用"><a href="#Block的使用" class="headerlink" title="Block的使用"></a>Block的使用</h4><pre><code>// 定义Block类型
typedef void(^Block)(NSString *name);
// 作为属性
@property (nonatomic, copy) void (^Block)(NSString *name);
// 作为参数
- (void)addAction:(void(^)(NSString *name))result;

Block block = ^(NSString *name){

};
self.Block = ^(NSString *name) {

};
void (^block)(NSString *temp) = ^(NSString *temp){

};</code></pre><h4 id="Block的内存管理"><a href="#Block的内存管理" class="headerlink" title="Block的内存管理"></a>Block的内存管理</h4><p>iOS 将Block分为三类，<strong>NSGlobalBlock</strong>，<strong>NSStackBlock</strong>，<strong>NSMallocBlock</strong>。其在内存中的存储如下。</p>
<table>
<thead>
<tr>
<th>Block</th>
<th>存储</th>
</tr>
</thead>
<tbody><tr>
<td><strong>NSGlobalBlock</strong></td>
<td>全局区</td>
</tr>
<tr>
<td><strong>NSStackBlock</strong></td>
<td>栈区</td>
</tr>
<tr>
<td><strong>NSMallocBlock</strong></td>
<td>堆区</td>
</tr>
</tbody></table>
<p><strong>NSGlobalBlock</strong>: 么有引用外部变量，或者引用了静态变量或全局变量</p>
<p><strong>NSStackBlock</strong>: 在MRC下，引用了外部局部变量的block</p>
<p><strong>NSMallocBlock</strong>: 在ARC下，引用了外部局部变量的block</p>
<p> <code>Note:在ARC下，引用了外部局部变量的block,会进行copy操作，所以在ARC下不存在__NSStackBlock__</code>。</p>
<h5 id="Block自己的内存管理"><a href="#Block自己的内存管理" class="headerlink" title="Block自己的内存管理"></a>Block自己的内存管理</h5><p>对于block，有两个内存管理方法：Block_copy, Block_release;Block_copy与copy等效， Block_release与release等效；</p>
<ul>
<li>不管是对block进行retian,copy,release,block的引用计数都不会增加，始终为1；</li>
<li>NSGlobalBlock:使用retain,copy, release都无效，block依旧存在全局区，且没有释放, 使用copy和retian只是返回block的指针；</li>
<li>NSStackBlock:使用retain,release操作无效；栈区block会在方法返回后将block空间回收； 使用copy将栈区block复制到堆区，可以长久保留block的空间，以供后面的程序使用；</li>
<li>NSMallocBlock:支持retian,release，虽然block的引用计数始终为1，但内存中还是会对引用进行管理，使用Block_copy引用+1， Block_release引用-1； 对于NSMallocBlock使用copy之后,不会产生新的block，只是增加了一次引用，类似于使用retian;</li>
</ul>
<h5 id="Block引用变量的内存管理"><a href="#Block引用变量的内存管理" class="headerlink" title="Block引用变量的内存管理"></a>Block引用变量的内存管理</h5><p>Block 引用局部变量，是值传递，引用全局变量和静态变量，是指针传递。<br>Block的结构如下：</p>
<p><img src="https://raw.githubusercontent.com/xuehan111/images/master/block_layout.png" alt="Block_Layout"></p>
<p>对于<strong>block修饰的变量，如:</strong>block int a = 10;会在栈区用block结构体方式保存。</p>
<pre><code>struct __Block_byref_b_0 {
      void *__isa;
    __Block_byref_b_0 *__forwarding;
     int __flags;
     int __size;
     int a;
};</code></pre><p>此时，__forwarding 指针指向block自身。</p>
<p><img src="https://raw.githubusercontent.com/xuehan111/images/master/stackBlock.png" alt="stackBlock.png"></p>
<p>使用Block_copy复制到对上之后，栈区的block中的__forwarding指向堆区的地址。</p>
<p><img src="https://raw.githubusercontent.com/xuehan111/images/master/heapBlock.png" alt="heapBlock.png"></p>
<h4 id="Blcok-copy"><a href="#Blcok-copy" class="headerlink" title="Blcok_copy"></a>Blcok_copy</h4><pre><code>void *_Block_copy(const void *arg) { 
    return _Block_copy_internal(arg, WANTS_ONE); 
} </code></pre><p>上面的方法调用了_Block_copy_internal()函数，查看_Block_copy_internal方法的实现：</p>
<pre><code>static void *_Block_copy_internal(const void *arg, const int flags) { 
    struct Block_layout *aBlock; 
    const bool wantsOne = (WANTS_ONE &amp;amp; flags) == WANTS_ONE; 

    // 1 
    if (!arg) return NULL; 

    // 2 
    aBlock = (struct Block_layout *)arg; 

    // 3 
    if (aBlock-&gt;flags &amp;amp; BLOCK_NEEDS_FREE) { 
        // latches on high 
        latching_incr_int(&amp;amp;aBlock-&gt;flags); 
        return aBlock; 
    } 

    // 4 
    else if (aBlock-&gt;flags &amp;amp; BLOCK_IS_GLOBAL) { 
        return aBlock; 
    } 

    // 5 
    struct Block_layout *result = malloc(aBlock&gt;descriptor-&gt;size); 
    if (!result) return (void *)0; 

    // 6 
    memmove(result, aBlock, aBlock-&gt;descriptor-&gt;size); // bitcopy first 

    // 7 
    result-&gt;flags &amp;amp;= ~(BLOCK_REFCOUNT_MASK);    // XXX not needed 
    result-&gt;flags |= BLOCK_NEEDS_FREE | 1; 

    // 8 
    result-&gt;isa = _NSConcreteMallocBlock; 

    // 9 
    if (result-&gt;flags &amp;amp; BLOCK_HAS_COPY_DISPOSE) { 
        (*aBlock-&gt;descriptor-&gt;copy)(result, aBlock); // do fixup 
    } 

    return result; 
} </code></pre><p>下面来看看该方法都做了些什么事情：</p>
<p>1、如果传入的参数是NULL则直接返回NULL。这样可以保证传入一个NULL block时函数的安全性。</p>
<p>2、将参数强制转换为一个指针，该指针指向一个Block_layout结构对象。实际上在第一集中就介绍了Block_layout结构：这是一个内部使用的数据结构，该结构组成一个block，其中包含一个block的实现函数，以及另外几个元数据。</p>
<p>3、 如果block的flags包含BLOCK_NEEDS_FREE，说明这是一个堆block(a heap block)。这种情况下，需要做的事情就是增加引用计数(reference count)，然后将同一个的block返回。</p>
<p>4、如果block是一个全局block(参考第一集)，那么不用做任何事情，直接返回同一个block即可——因为全局block是一个单例(singleton)。</p>
<p>5、如果到这一步了，可以肯定该block肯定被分配在栈上。这种情况，需要将block拷贝到堆上。这也是最有趣的一部分。首先是利用malloc()函数在堆上创建block对应size大小的内存空间。如果失败了，就返回NULL，否则继续往下执行。</p>
<p>6、 利用memmove()函数将分配在栈中的block按位拷贝至刚刚在堆上分配的空间中。按位拷贝可以确保block中的所有元数据都能准确的进行拷贝，例如block的descriptor。</p>
<p>7、接着需要更新一下block的flags。第一行代码是确保引用计数被设置为0。后面紧跟的注释表示这不是必须的——估计此时引用计数已经是0了。我猜测这行代码的作用是为了防止潜在的bug，会引起引用计数不为0的情况。第二行代码是设置BLOCK_NEEDS_FREE标志，这标示该block是一个堆block，当引用计数变为0时，需要free掉。后面紧跟的| 1是将block的引用计数设置为1。</p>
<p>8、将block的isa指针设置为 _NSConcreteMallocBlock，这就意味着该block是一个堆block。</p>
<p>9、最后，如果block有一个拷贝辅助函数(a copy helper function)，那么就调用它。如果有必要的话，表一起会生成一个拷贝辅助函数。例如block需要拷贝对象的时候，拷贝辅助函数会retain住已经拷贝的对象。</p>
<p>####Block_release<br>与Block_copy对应的是Block_release()。同样，Block_release()也是一个宏定义，如下所示：</p>
<pre><code>#define Block_release(...) _Block_release((const void *)(__VA_ARGS__)) 

void _Block_release(void *arg) { 
    // 1 
    struct Block_layout *aBlock = (struct Block_layout *)arg; 
    if (!aBlock) return; 

    // 2 
    int32_t newCount; 
    newCount = latching_decr_int(&amp;amp;aBlock-&gt;flags) &amp;amp; BLOCK_REFCOUNT_MASK; 

    // 3 
    if (newCount &gt; 0) return; 

    // 4 
    if (aBlock-&gt;flags &amp;amp; BLOCK_NEEDS_FREE) { 
        if (aBlock-&gt;flags &amp;amp; BLOCK_HAS_COPY_DISPOSE)(*aBlock-&gt;descriptor-&gt;dispose)(aBlock); 
        _Block_deallocator(aBlock); 
    } 

    // 5 
    else if (aBlock-&gt;flags &amp;amp; BLOCK_IS_GLOBAL) { 
        ; 
    } 

    // 6 
    else { 
        printf(&quot;Block_release called upon a stack Block: %p, ignored\n&quot;, (void *)aBlock); 
    } 
} </code></pre><p>1、 首先将参数强制转换为Block_layout结构。如果传入的是NULL，那么为了函数的安全起见，将直接返回。</p>
<p>2、将block的引用计数标志位减1(还记得Block_copy()中将这个引用计数标志位设置为1吗？)。</p>
<p>3、如果newCount大于0，说明还有别的对象引用了这个block，所以并不需要立即释放block，只需简单的返回即可。</p>
<p>4、否则，如果flags中包含BLOCK_NEEDS_FREE，那么说明这个block是分配到堆上的，并且如果引用计数为0，那么需要释放这个block。首先是调用了block的dispose辅助函数，该函数跟copy辅助函数相反，负责做相反的操作，例如释放掉所有在block中拷贝的变量等。最后使用_Block_deallocator函数释放掉block，如果你去runtime.c文件中看看，会发现该函数的尾部是一个指向free的函数指针，也就是释放掉malloc分配的内存。</p>
<p>5、如果block是全局的，那么什么事情也不用做。</p>
<p>6、如果代码执行到这里了，会发生一些奇怪的事情：因为正在尝试将栈上的block释放掉，所以这行代码是为了提醒开发者的。在程序实际运行过程中，永远不会看到这里的提示。</p>
<h4 id="Block-循环引用的解决"><a href="#Block-循环引用的解决" class="headerlink" title="Block 循环引用的解决"></a>Block 循环引用的解决</h4>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://blog.lemongame.top/undefined/weak/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="疯狂小柠檬">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Lemon's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/undefined/weak/" itemprop="url">weak</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-05-22T22:56:53+08:00">
                2019-05-22
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>在iOS中，我们经常用weak来解决循环引用的问题。<strong>weak关键字的作用弱引用，所引用对象的计数器不会加一，并在引用对象被释放的时候自动被设置为 nil</strong></p>
<h3 id="weak实现原理"><a href="#weak实现原理" class="headerlink" title="weak实现原理"></a>weak实现原理</h3><p>当我们初始化一个weak变量时，runtime做了如下操作:</p>
<p>1、初始化weak指针。</p>
<p>2、存储weak对象。</p>
<p>3、返回weak对象。</p>
<h4 id="初始化weak指针。"><a href="#初始化weak指针。" class="headerlink" title="初始化weak指针。"></a>初始化weak指针。</h4><p>runtime调用objc_initWeak方法，来初始化一个weak指针，并做了判空处理。之后会调用objc_storeWeak方法来存储weak对象</p>
<pre><code>/** 
 * Initialize a fresh weak pointer to some object location. 
 * It would be used for code like: 
 *
 * (The nil case) 
 * __weak id weakPtr;
 * (The non-nil case) 
 * NSObject *o = ...;
 * __weak id weakPtr = o;
 * 
 * @param addr Address of __weak ptr. 
 * @param val Object ptr. 
 */
id objc_initWeak(id *addr, id val)
{
    *addr = 0;
    if (!val) return nil;
    return objc_storeWeak(addr, val); // 存储weak对象
}</code></pre><h4 id="存储weak对象。"><a href="#存储weak对象。" class="headerlink" title="存储weak对象。"></a>存储weak对象。</h4><p>runtime使用objc_storeWeak方法来存储weak对象，objc_storeWeak的方法实现如下:</p>
<pre><code>/**
* This function is typically used anywhere a __weak variable is     * the target of an assignment.
* Parameters

* @param location  The address of the weak pointer.
* @param obj The new object you want the weak pointer to now     * point to.
* 
* @return  The value stored in location (that is, obj).
*
*/
template &lt;HaveOld haveOld, HaveNew haveNew,
          CrashIfDeallocating crashIfDeallocating&gt;
static id storeWeak(id *location, objc_object *newObj)
{
    assert(haveOld  ||  haveNew);
    if (!haveNew) assert(newObj == nil);

    Class previouslyInitializedClass = nil;
    id oldObj;
    SideTable *oldTable;
    SideTable *newTable;

    // Acquire locks for old and new values.
    // Order by lock address to prevent lock ordering problems. 
    // Retry if the old value changes underneath us.
 retry:
    if (haveOld) {
        oldObj = *location;
        oldTable = &amp;SideTables()[oldObj];
    } else {
        oldTable = nil;
    }
    if (haveNew) {
        newTable = &amp;SideTables()[newObj];
    } else {
        newTable = nil;
    }

    SideTable::lockTwo&lt;haveOld, haveNew&gt;(oldTable, newTable);

    if (haveOld  &amp;&amp;  *location != oldObj) {
        SideTable::unlockTwo&lt;haveOld, haveNew&gt;(oldTable, newTable);
        goto retry;
    }

    // Prevent a deadlock between the weak reference machinery
    // and the +initialize machinery by ensuring that no 
    // weakly-referenced object has an un-+initialized isa.
    if (haveNew  &amp;&amp;  newObj) {
        Class cls = newObj-&gt;getIsa();
        if (cls != previouslyInitializedClass  &amp;&amp;  
            !((objc_class *)cls)-&gt;isInitialized()) 
        {
            SideTable::unlockTwo&lt;haveOld, haveNew&gt;(oldTable, newTable);
            _class_initialize(_class_getNonMetaClass(cls, (id)newObj));

            // If this class is finished with +initialize then we&apos;re good.
            // If this class is still running +initialize on this thread 
            // (i.e. +initialize called storeWeak on an instance of itself)
            // then we may proceed but it will appear initializing and 
            // not yet initialized to the check above.
            // Instead set previouslyInitializedClass to recognize it on retry.
            previouslyInitializedClass = cls;

            goto retry;
        }
    }

    // Clean up old value, if any.
    if (haveOld) {
        weak_unregister_no_lock(&amp;oldTable-&gt;weak_table, oldObj, location);
    }

    // Assign new value, if any.
    if (haveNew) {
        newObj = (objc_object *)
            weak_register_no_lock(&amp;newTable-&gt;weak_table, (id)newObj, location, 
                                  crashIfDeallocating);
        // weak_register_no_lock returns nil if weak store should be rejected

        // Set is-weakly-referenced bit in refcount table.
        if (newObj  &amp;&amp;  !newObj-&gt;isTaggedPointer()) {
            newObj-&gt;setWeaklyReferenced_nolock();
        }

        // Do not set *location anywhere else. That would introduce a race.
        *location = (id)newObj;
    }
    else {
        // No new value. The storage is not changed.
    }

    SideTable::unlockTwo&lt;haveOld, haveNew&gt;(oldTable, newTable);

    return (id)newObj;
}</code></pre><p> objc_storeWeak() 的作用是更新指针指向，创建对应的弱引用表.在这个过程中，runtime先解除weak指针对旧对象的引用，然后修改指针指向新对象，最后返回新对象</p>
<h3 id="weak存储结构"><a href="#weak存储结构" class="headerlink" title="weak存储结构"></a>weak存储结构</h3><p> <img src="https://raw.githubusercontent.com/xuehan111/images/master/weak%E7%BB%93%E6%9E%84.png" alt="weak存储结构"></p>
<p><code>SideTables</code>是一个64个元素长度的hash数组，里面存储了SideTable。SideTables的hash键值就是一个对象obj的地址。一个obj，对应了一个SideTable，但是一个SideTable，会对应多个obj，因为SideTable的数量只有64个，所以会有很多obj共用同一个SideTable。</p>
<p>而在一个SideTable中，又有两个成员:</p>
<pre><code>RefcountMap refcnts;        // 对象引用计数相关 map
weak_table_t weak_table;    // 对象弱引用相关 table</code></pre><ul>
<li>refcents是一个hash map，其key是obj的地址，而value，则是obj对象的引用计数。</li>
<li>weak_table用来存储OC对象弱引用的相关信息。由于一个weak_table会存储多个对象的弱引用信息。因此在一个SideTable中，又会通过weak_table作为hash表再次分散存储每一个对象的弱引用信息。weak_table中的weak_entries 存储了多个对象的弱引用。</li>
<li>weak_entries: 该数组中存储着weak_entrie_t,而每个weak_entrie_t则存储着单个对象的地址(referent)及其所有弱引用(referrers)</li>
</ul>
<h3 id="Weak指针置为nil"><a href="#Weak指针置为nil" class="headerlink" title="Weak指针置为nil"></a>Weak指针置为nil</h3><p>runtime对象的释放流程如下:</p>
<p><img src="https://raw.githubusercontent.com/xuehan111/images/master/objc_release.png" alt="release"></p>
<p>1、对象调用release</p>
<p>2、判断对象的引用计数如果为0，则调用dealloc</p>
<p>3、在dealloc中,经过一系列的封装回调方法，最终会调用到weak_clear_no_lock方法，在该方法中，处理了weak指针的置nil操作。</p>
<p>weak_clear_no_lock的方法实现如下:</p>
<pre><code>/** 
 * Called by dealloc; nils out all weak pointers that point to the 
 * provided object so that they can no longer be used.
 * 
 * @param weak_table 
 * @param referent The object being deallocated. 
 */
void 
weak_clear_no_lock(weak_table_t *weak_table, id referent_id) 
{
    objc_object *referent = (objc_object *)referent_id;

    weak_entry_t *entry = weak_entry_for_referent(weak_table, referent);
    if (entry == nil) {
        /// XXX shouldn&apos;t happen, but does with mismatched CF/objc
        //printf(&quot;XXX no entry for clear deallocating %p\n&quot;, referent);
        return;
    }

    // zero out references
    weak_referrer_t *referrers;
    size_t count;

    if (entry-&gt;out_of_line()) {
        referrers = entry-&gt;referrers;
        count = TABLE_SIZE(entry);
    } 
    else {
        referrers = entry-&gt;inline_referrers;
        count = WEAK_INLINE_COUNT;
    }

    for (size_t i = 0; i &lt; count; ++i) {
        objc_object **referrer = referrers[i];
        if (referrer) {
            if (*referrer == referent) {
                *referrer = nil;
            }
            else if (*referrer) {
                _objc_inform(&quot;__weak variable at %p holds %p instead of %p. &quot;
                             &quot;This is probably incorrect use of &quot;
                             &quot;objc_storeWeak() and objc_loadWeak(). &quot;
                             &quot;Break on objc_weak_error to debug.\n&quot;, 
                             referrer, (void*)*referrer, (void*)referent);
                objc_weak_error();
            }
        }
    }

    weak_entry_remove(weak_table, entry);
}</code></pre><p>该方法中，通过释放对象的地址，先找到其弱引用所在的weak_table,然后，找到存放该对象所有弱引用的weak_entry_t,遍历weak_entry_t 中的 referrers，对所有弱引用对象置nil。</p>
<p>clearDeallocating_slow的实现如下:</p>
<pre><code>// Slow path of clearDeallocating() 
// for objects with nonpointer isa
// that were ever weakly referenced 
// or whose retain count ever overflowed to the side table.
NEVER_INLINE void
objc_object::clearDeallocating_slow()
{
    assert(isa.nonpointer  &amp;&amp;  (isa.weakly_referenced || isa.has_sidetable_rc));

    SideTable&amp; table = SideTables()[this];
    table.lock();
    if (isa.weakly_referenced) {
        weak_clear_no_lock(&amp;table.weak_table, (id)this);
    }
    if (isa.has_sidetable_rc) {
        table.refcnts.erase(this);
    }
    table.unlock();
}</code></pre><p>由该函数实现可以看出，weak指针置为nil的过程中，在table这一层，加了锁，因此weak指针置为nil的过程是线程安全的。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><strong>weak的底层维护了一个弱引用表，在引用的对象释放之后，会根据释放对象的地址找到该对象的所有弱引用，并将弱引用指针置为nil。此过程是线程安全的。</strong></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://blog.lemongame.top/undefined/charles原理/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="疯狂小柠檬">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Lemon's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/undefined/charles原理/" itemprop="url">charles原理</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-04-03T18:45:49+08:00">
                2019-04-03
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="Charles抓包原理"><a href="#Charles抓包原理" class="headerlink" title="Charles抓包原理"></a>Charles抓包原理</h3><p>HTTPS为了兼顾安全与效率，同时使用了对称加密和非对称加密。数据是被对称加密传输的，对称加密过程需要客户端的一个密钥，为了确保能把该密钥安全传输到服务器端，采用非对称加密对该密钥进行加密传输，总的来说，对数据进行对称加密，对称加密所要使用的密钥通过非对称加密传输。</p>
<p>Charles抓包采用的是中间人代理的模式</p>
<p><img src="https://raw.githubusercontent.com/xuehan111/images/master/charles.png" alt="charles.png"></p>
<p>1、客户端向服务器请求CA证书</p>
<p>2、Charles拦截客户端的请求，伪装成客户端向服务器请求</p>
<p>3、服务器向客户端(Charles)返回服务器自己的CA证书</p>
<p>4、Charles拦截服务器的响应，获取服务器证书公钥，然后自己制作一张证书，将服务器证书替换后发送给客户端。（这一步，Charles拿到了服务器证书的公钥）</p>
<p>5、客户端接收到“服务器”（实际上是Charles）的证书后，生成一个对称密钥，用Charles的公钥加密，发送给“服务器”（Charles）</p>
<p>6、Charles拦截客户端的响应，用自己的私钥解密对称密钥，然后用服务器证书公钥加密，发送给服务器。（这一步，Charles拿到了对称密钥</p>
<p>7、服务器用自己的私钥解密对称密钥，向“客户端”（Charles）发送响应</p>
<p>8、Charles拦截服务器的响应，替换成自己的证书后发送给客户端</p>
<p>9、至此，连接建立，Charles拿到了 服务器证书的公钥 和 客户端与服务器协商的对称密钥，之后就可以解密或者修改加密的报文了。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://blog.lemongame.top/undefined/App的编译过程/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="疯狂小柠檬">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Lemon's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/undefined/App的编译过程/" itemprop="url">App的编译过程</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-03-29T22:35:26+08:00">
                2019-03-29
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="App的编译"><a href="#App的编译" class="headerlink" title="App的编译"></a>App的编译</h3><h4 id="Command-R发生了什么"><a href="#Command-R发生了什么" class="headerlink" title="Command+R发生了什么"></a>Command+R发生了什么</h4><ul>
<li>写入辅助文件：将项目的文件结构对应表、将要执行的脚本、项目依赖库的文件结构对应表写成文件，方便后面使用；并且创建一个 .app 包，后面编译后的文件都会被放入包中；</li>
<li>运行预设脚本：Cocoapods 会预设一些脚本，当然你也可以自己预设一些脚本来运行。这些脚本都在 Build Phases 中可以看到；</li>
<li>编译文件：针对每一个文件进行编译，生成可执行文件 Mach-O，这过程 LLVM 的完整流程，前端、优化器、后端；</li>
<li>链接文件：将项目中的多个可执行文件合并成一个文件；</li>
<li>拷贝资源文件：将项目中的资源文件拷贝到目标包；</li>
<li>编译 storyboard 文件：storyboard 文件也是会被编译的；</li>
<li>链接 storyboard 文件：将编译后的 storyboard 文件链接成一个文件；</li>
<li>编译 Asset 文件：我们的图片如果使用 Assets.xcassets 来管理图片，那么这* 些图片将会被编译成机器码，除了 icon 和 launchImage；</li>
<li>运行 Cocoapods 脚本：将在编译项目之前已经编译好的依赖库和相关资源拷贝到包中。</li>
<li>生成 .app 包</li>
<li>对包进行签名、验证</li>
</ul>
<h3 id="编译优化"><a href="#编译优化" class="headerlink" title="编译优化"></a>编译优化</h3><ul>
<li><p>Build Active Architecture Only</p>
<pre><code>Note: 
在Debug模式下，设置为YES，只会生成指定指令集的二进制包,
在release模式下设置为NO</code></pre></li>
<li><p>Optimization Level</p>
<pre><code>该变量有以下值可以设置
* None: 编译器不会尝试优化代码，当你专注解决逻辑错误、编译速度快时使用此项。</code></pre><ul>
<li><p>Fast: 编译器执行简单的优化来提高代码的性能，同时最大限度的减少编译时间，该选项在编译过程中会使用更多的内存。</p>
</li>
<li><p>Faster: 编译器执行所有优化，增加编译时间，提高代码的性能。</p>
</li>
<li><p>Fastest: 编译器执行所有优化，改善代码的速度，但会增加代码长度，编译速度慢。</p>
</li>
<li><p>Fastest, Smallest: 编译器执行所有优化，不会增加代码的长度，它是执行文件占用更少内存的首选方案</p>
<pre><code>在Debug环境下设置为None，从而减少编译时间
在Release环境下设置为Fastest, Smalllest，这样既能执行所有的优化而不增加代码长度，又能使执行文件占用更少的内存</code></pre></li>
</ul>
</li>
<li><p>Debug Information Format</p>
<p>  该值表示是否将调试信息加入到可执行文件中，即是否生成dSYM文件</p>
<ul>
<li><p>DWARF  不生成dSYM调试文件</p>
</li>
<li><p>DWARF with dSYM file  生成调试文件</p>
<pre><code>在Debug环境下设置为DWARF，在release环境下设置为DWARF with dSYM file</code></pre></li>
</ul>
</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://blog.lemongame.top/undefined/App启动/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="疯狂小柠檬">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Lemon's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/undefined/App启动/" itemprop="url">App启动</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-03-25T18:39:35+08:00">
                2019-03-25
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="App启动加载"><a href="#App启动加载" class="headerlink" title="App启动加载"></a>App启动加载</h3><p>当我们点击App图标时，便进入了App的启动过程，整个过程大致进行了如下操作:<br><img src="https://raw.githubusercontent.com/xuehan111/images/master/ios_app_start.png" alt="app start"></p>
<h3 id="启动优化"><a href="#启动优化" class="headerlink" title="启动优化"></a>启动优化</h3><p><a href="http://www.cocoachina.com/ios/20180802/24423.html" target="_blank" rel="noopener">链接</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://blog.lemongame.top/undefined/oc锁/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="疯狂小柠檬">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Lemon's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/undefined/oc锁/" itemprop="url">oc锁</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-02-11T20:11:05+08:00">
                2019-02-11
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="OC中的锁"><a href="#OC中的锁" class="headerlink" title="OC中的锁"></a>OC中的锁</h3><h4 id="NSLock"><a href="#NSLock" class="headerlink" title="NSLock"></a>NSLock</h4><p>NSLock是一个互斥锁。其使用方式如下:</p>
<pre><code>- (void)demoAction {
   [self.lock lock];
   //TODO: do your action
   [self.lock unlock];
}</code></pre><p>当一个线程进行访问的时候，该线程获得锁，其他线程进行访问的时候，将被操作系统挂起，直到该线程释放锁，其他线程才能对其进行访问，从而却确保了线程安全。但是如果连续锁定两次，则会造成死锁问题。</p>
<pre><code>- (void)demoAction {
   [self.lock lock];
   //TODO: do your action
   [self.lock lock];
   //TODO: do your action
   [self.lock unlock];
   [self.lock unlock];
}</code></pre><p>上面的这种情况会造成死锁。</p>
<h4 id="NSRecursiveLock-递归锁"><a href="#NSRecursiveLock-递归锁" class="headerlink" title="NSRecursiveLock 递归锁"></a>NSRecursiveLock 递归锁</h4><p>递归锁，允许在同一个线程中多次获得锁，而不会造成死锁。</p>
<pre><code>void recursiveAction(int count) {
    [_recursiveLock lock];
    if(count &lt;= 0) return;
    NSLog(@&quot;%d&quot;,count);
    recursiveAction(--count);
    [_recursiveLock unlock];
}</code></pre><h4 id="synchronized-便捷的创建互斥锁的方式"><a href="#synchronized-便捷的创建互斥锁的方式" class="headerlink" title="@synchronized 便捷的创建互斥锁的方式"></a>@synchronized 便捷的创建互斥锁的方式</h4><pre><code>@synchronized (self) {
    // action
}</code></pre><h4 id="NSCondition"><a href="#NSCondition" class="headerlink" title="NSCondition"></a>NSCondition</h4><p> 条件锁，通过它可以实现不同线程的调度。一个线程被某一个条件所阻塞，直到另一个线程满足该条件从而发送信号给该线程使得该线程可以正确的执行。</p>
<pre><code> - (void)action1 {
    [self.condition lock];
    dispatch_async(dispatch_get_global_queue(0, 0), ^{
        // TODO: action1
        self.finish = YES;
        [self.condition signal];
        [self.condition unlock];
    });
}
- (void)action2 {
    [self.condition lock];
    while (!self.finish) {
        [self.condition wait];
    }
    // TODO: action2
    [self.condition unlock];
}</code></pre><h4 id="NSConditionLock"><a href="#NSConditionLock" class="headerlink" title="NSConditionLock"></a>NSConditionLock</h4><p>该对象所定义的互斥锁可以在使得在某个条件下进行锁定和解锁。它和 NSCondition 很像，但实现方式是不同的。</p>
<p>当两个线程需要特定顺序执行的时候，例如生产者消费者模型，则可以使用 NSConditionLock 。当生产者执行执行的时候，消费者可以通过特定的条件获得锁，当生产者完成执行的时候，它将解锁该锁，然后把锁的条件设置成唤醒消费者线程的条件。锁定和解锁的调用可以随意组合，lock 和 unlockWithCondition: 配合使用 lockWhenCondition: 和 unlock 配合使用</p>
<pre><code>- (void)producer {
    while (YES) {
        [self.conditionLock lock];
        NSLog(@&quot;have something&quot;);
        self.count++;
        [self.conditionLock unlockWithCondition:1];
    }
}
- (void)consumer {
    while (YES) {
        [self.conditionLock lockWhenCondition:1];
        NSLog(@&quot;use something&quot;);
        self.count--;
        [self.conditionLock unlockWithCondition:0];
    }
}</code></pre><h4 id="pthread-mutex"><a href="#pthread-mutex" class="headerlink" title="pthread_mutex"></a>pthread_mutex</h4><p>POSIX 互斥锁是一种超级易用的互斥锁，使用的时候，只需要初始化一个 pthread_mutex_t 用 pthread_mutex_lock 来锁定 pthread_mutex_unlock 来解锁，当使用完成后，记得调用 pthread_mutex_destroy 来销毁锁。</p>
<pre><code>pthread_mutex_t lock;
pthread_mutex_init(&amp;lock,NULL);
pthread_mutex_lock(&amp;lock);
//do your action
pthread_mutex_unlock(&amp;lock);
pthread_mutex_destroy(&amp;lock);</code></pre><p>该锁可以初始化时，可以通过设置type设置成 递归锁</p>
<pre><code>pthread_mutex_t lock;
pthread_mutexattr_t mattr;
int ret;
ret = pthread_mutexattr_init(&amp;mattr);
pthread_mutexattr_settype(&amp;mattr, PTHREAD_MUTEX_RECURSIVE);
pthread_mutex_init(&amp;lock,&amp;mattr);
pthread_mutex_lock(&amp;lock);
// TODO: 
pthread_mutex_unlock(&amp;lock);
pthread_mutex_destroy(&amp;lock);</code></pre><h4 id="pthread-rwlock-读写锁"><a href="#pthread-rwlock-读写锁" class="headerlink" title="pthread_rwlock 读写锁"></a>pthread_rwlock 读写锁</h4><p> 读写锁，在对文件进行操作的时候，写操作是排他的，一旦有多个线程对同一个文件进行写操作，后果不可估量，但读是可以的，多个线程读取时没有问题的。</p>
<ul>
<li>当读写锁被一个线程以读模式占用的时候，写操作的其他线程会被阻塞，读操作的其他线程还可以继续进行。</li>
<li>当读写锁被一个线程以写模式占用的时候，写操作的其他线程会被阻塞，读操作的其他线程也被阻塞。</li>
</ul>
<pre><code> pthread_rwlock_t rwlock = PTHREAD_RWLOCK_INITIALIZER;
- (void)readAction {
    pthread_rwlock_rdlock(&amp;rwlock);
    // TODO: 读文件
    pthread_rwlock_unlock(&amp;rwlock);
}
- (void)writeAction {
    pthread_rwlock_wrlock(&amp;rwlock);
    // TODO: 写文件
    pthread_rwlock_unlock(&amp;rwlock);
}</code></pre><h4 id="POSIX-Conditions-条件锁"><a href="#POSIX-Conditions-条件锁" class="headerlink" title="POSIX Conditions 条件锁"></a>POSIX Conditions 条件锁</h4><p>POSIX条件锁和NSCondition条件锁类似，只不过POSIX条件锁偏底层实现。</p>
<pre><code>pthread_mutex_t p_mutex_lock;
pthread_cond_t p_condition;

pthread_mutex_init(&amp;p_mutex_lock,NULL);
pthread_cond_init(&amp;p_condition, NULL);

- (void)action1 {
    pthread_mutex_lock(&amp;p_mutex_lock);
    NSLog(@&quot;action1&quot;);
    dispatch_async(dispatch_get_global_queue(0, 0), ^{
        // action1
        [NSThread sleepForTimeInterval:3];
        self.finish = YES;
        pthread_cond_signal(&amp;p_condition);
        pthread_mutex_unlock(&amp;p_mutex_lock);
    });
}
- (void)action2 {
    pthread_mutex_lock(&amp;p_mutex_lock);
    while (!self.finish) {
        pthread_cond_wait(&amp;p_condition, &amp;p_mutex_lock);
    }
    NSLog(@&quot;action2&quot;);
    pthread_mutex_unlock(&amp;p_mutex_lock);
}</code></pre><h4 id="OSSpinLock-自旋锁"><a href="#OSSpinLock-自旋锁" class="headerlink" title="OSSpinLock 自旋锁"></a>OSSpinLock 自旋锁</h4><p>自旋锁和互斥锁的区别在于：</p>
<ul>
<li>互斥锁，当一个线程获得这个锁之后，其他想要获得此锁的线程将会被阻塞，直到该锁被释放</li>
<li>自旋锁：当一个线程获得锁之后，其他线程将会一直循环在哪里查看是否该锁被释放</li>
</ul>
<pre><code>OSSpinLock spinLock = OS_SPINLOCK_INIT;
    OSSpinLockLock(&amp;spinLock);
// TODO: do your action
OSSpinLockUnlock(&amp;spinLock);</code></pre><p> ** 由于安全问题，OSSpinLock已被苹果废弃**</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://blog.lemongame.top/undefined/OC与JS交互原理/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="疯狂小柠檬">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Lemon's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/undefined/OC与JS交互原理/" itemprop="url">OC与JS交互原理</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-01-27T12:15:31+08:00">
                2019-01-27
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>OC 与 JS 的交互是基于 JavaScriptCore 框架。JavaScriptCore是苹果Safari浏览器的JavaScript引擎，其提供了 JS解析和执行环境，使得我们可以脱离webview直接运行我们的js。该框架充当了 OC 和 JS 代码的桥梁。<br><img src="https://raw.githubusercontent.com/xuehan111/images/master/oc_js%E4%BA%A4%E4%BA%92.png" alt="oc_js交互.png"></p>
<h3 id="OC-与-JS-交互示例"><a href="#OC-与-JS-交互示例" class="headerlink" title="OC 与 JS 交互示例"></a>OC 与 JS 交互示例</h3><h4 id="OC调用JS方法"><a href="#OC调用JS方法" class="headerlink" title="OC调用JS方法"></a>OC调用JS方法</h4><pre><code>NSString *jsCode = @&quot;function A(){return 10;}&quot;;
JSContext *context = [[JSContext alloc] init];
[context evaluateScript:jsCode];
JSValue *value = [context evaluateScript:@&quot;A()&quot;];
NSLog(@&quot;%d&quot;, [value toInt32]);</code></pre><h4 id="JS调用OC方法"><a href="#JS调用OC方法" class="headerlink" title="JS调用OC方法"></a>JS调用OC方法</h4><pre><code>JSContext *context = [[JSContext alloc] init];
// 初始化方法
context[@&quot;test&quot;] =  ^() {
    NSLog(@&quot;1230&quot;);
};
// 调用方法
 [context evaluateScript:@&quot;test()&quot;];</code></pre><h3 id="OC-与-JS-交互原理"><a href="#OC-与-JS-交互原理" class="headerlink" title="OC 与 JS 交互原理"></a>OC 与 JS 交互原理</h3><p> 先了解下JavaScriptCore 框架中的几个对象: JSVirtualMachine、JSContext、JSValue、JSManagedValue</p>
<h4 id="JSVirtualMachine"><a href="#JSVirtualMachine" class="headerlink" title="JSVirtualMachine"></a>JSVirtualMachine</h4><p>从字面意思上看，是JS虚拟机。一个JSVirtualMachine实例代表了一个 JS运行环境，或者可以说是一系列JS运行所需的资源。该类有两个主要的使用用途：一是支持并发的JS调用，二是管理JS和Native之间桥对象的内存。</p>
<p>JS是单线程机制，在一个JSVirtualMachine中，只有一条线程可以执行JS代码，所以我们无法在一个JSVirtualMachine进行多线程处理JS任务。如果要多线程处理JS任务，就需要同时生成多个JSVirtualMachine，从而达到多线程处理的目的。</p>
<h4 id="JSContext"><a href="#JSContext" class="headerlink" title="JSContext"></a>JSContext</h4><p> 每个JSContext都从属于一个JSVirtualMachine，一个JSVirtualMachine可以包含多个JSContext。</p>
<p> JSContext负责JS语言的执行，JS代码的执行必须在JSContext之中。我们可以通过创建一个JSContext去调用JS脚本，访问一些JS定义的值和函数，同时JSContext也提供了让JS访问Native对象，方法的接口。</p>
<p> JSContext 的属性中有个 globalObject对象，它返回当前执行JSContext的全局对象，这个globalObject对象就是 JSContext的核心。我们在原生中对js的交互，其实就是在跟这个对象交互。globalObject对象存储了我们注入到JS中的原生方法以及我们在执行JS代码后，生成的变量和函数。在WebKit中，JSContext返回的global对象就是 Window对象。</p>
<h4 id="JSValue"><a href="#JSValue" class="headerlink" title="JSValue"></a>JSValue</h4><p>OC 是不可以直接使用 JS 的变量和函数的，同时，JS 也是不可以直接使用 OC 的变量和方法的。因此，需要经过转化之后才可以使用。JSValue 可以实现OC 和 JS值的相互转化。一个JSValue 代表了一个JS值的引用。</p>
<p>OC 和 JS 类型转化关系如下:</p>
<table>
<thead>
<tr>
<th>Objective-C type</th>
<th>JavaScript type</th>
</tr>
</thead>
<tbody><tr>
<td>nil</td>
<td>undefined</td>
</tr>
<tr>
<td>NSNull</td>
<td>null</td>
</tr>
<tr>
<td>NSString</td>
<td>string</td>
</tr>
<tr>
<td>NSNumber</td>
<td>number, boolean</td>
</tr>
<tr>
<td>NSDictionary</td>
<td>Object object</td>
</tr>
<tr>
<td>NSArray</td>
<td>Array object</td>
</tr>
<tr>
<td>NSDate</td>
<td>Date object</td>
</tr>
<tr>
<td>NSBlock</td>
<td>Function object</td>
</tr>
<tr>
<td>id</td>
<td>Wrapper object</td>
</tr>
<tr>
<td>Class</td>
<td>Constructor object</td>
</tr>
</tbody></table>
<h5 id="NSDictionary-lt-—-gt-js-Object"><a href="#NSDictionary-lt-—-gt-js-Object" class="headerlink" title="NSDictionary &lt;—&gt; js Object"></a>NSDictionary &lt;—&gt; js Object</h5><p> OC 的 NSDictionary是key，value键值对形式，JS 的 Object 也是 键值(key,value)的形式.因此可以相互转化。</p>
<pre><code>var person = {&quot;name&quot;: &quot;xuehan&quot;, &quot;age&quot;: 10 }; // js Object
NSDictionary *dict = @{@&quot;name&quot;: @&quot;xuehan&quot;, @&quot;age&quot;: @10} //  OC NSDictionary</code></pre><h5 id="NSBlock-lt-—-gt-js-Function"><a href="#NSBlock-lt-—-gt-js-Function" class="headerlink" title="NSBlock &lt;—&gt; js Function"></a>NSBlock &lt;—&gt; js Function</h5><p> OC 中的Block，本质上就是一个包裹了函数指针的类。而 JS 中的函数实际上也是一个”Function”类型的对象，函数名 其实就是指向一个函数对象的引用。因此可以相互转化</p>
<pre><code>// OC block
void (^Block)() = ^{
    NSLog(@&quot;123&quot;);
}
// js 函数
var test = function(){
    return 10;
}</code></pre><h4 id="JSManagedValue"><a href="#JSManagedValue" class="headerlink" title="JSManagedValue"></a>JSManagedValue</h4><p>JS内存管理是垃圾回收，并且JS中的对象都是强引用，而OC是引用计数。如果双方相互引用，势必会造成循环引用，而导致内存泄露。我们可以用JSManagedValue保存JSValue来避免.</p>
<p>JSManagedValue 采用了 “conditionally retained” 机制来管理 内存，即 只要对象能通过 JS object graph 或者  通过 addManagedReference:withOwner: 方式告知给 JSVirtualMachine 的 Objective-C object graph 访问到，就不会释放。</p>
<h4 id="交互原理"><a href="#交互原理" class="headerlink" title="交互原理"></a>交互原理</h4><p>OC 调用JS方法时，是通过 JSContext的 evaluateScript 方法的执行 js 代码。该方法在globalObject中保存了生成的变量和方法，同时将值以JSValue的形式存储起来。 </p>
<p>JS 调用 OC 原生方法，需要将原生代码先通过JSContext转化为JSValue的形式，注入到 JSContext中的globalObject里面（示例是通过Block的方式将原生方法注入到globalObject中去的。</p>
<p>这样，无论原生代码还是JS代码，最终都将信息通过JSValue的方式保存在了globalObject中，在交互时，通过JSContext 获取到对应的 JSValue, 即可实现交互。在JS 调用原生代码时，通过拿到对应的JSValue，然后取出 invocation，来实现动态调用原生方法的。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/images/avatar.gif" alt="疯狂小柠檬">
            
              <p class="site-author-name" itemprop="name">疯狂小柠檬</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives">
              
                  <span class="site-state-item-count">23</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            

            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; 2015 &mdash; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">疯狂小柠檬</span>

  
</div>









        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.3"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.3"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.3"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
